<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Smallweb</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Self-Hosting</li><li class="chapter-item expanded "><a href="localhost/localhost.html"><strong aria-hidden="true">1.</strong> Localhost setup</a></li><li class="chapter-item expanded "><a href="cloudflare/tunnel.html"><strong aria-hidden="true">2.</strong> Cloudflare setup</a></li><li class="chapter-item expanded "><a href="fly/setup.html"><strong aria-hidden="true">3.</strong> Fly.io setup</a></li><li class="chapter-item expanded affix "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="guides/hono.html"><strong aria-hidden="true">4.</strong> Creating Services with Hono</a></li><li class="chapter-item expanded "><a href="guides/jsr.html"><strong aria-hidden="true">5.</strong> Installing Apps from JSR</a></li><li class="chapter-item expanded "><a href="guides/vite.html"><strong aria-hidden="true">6.</strong> Integrating with Vite</a></li><li class="chapter-item expanded "><a href="guides/astro.html"><strong aria-hidden="true">7.</strong> Integrating with Astro</a></li><li class="chapter-item expanded "><a href="guides/telegram.html"><strong aria-hidden="true">8.</strong> Building a Telegram Bot</a></li><li class="chapter-item expanded affix "><li class="part-title">Moving to the cloud</li><li class="chapter-item expanded "><a href="deno-deploy.html"><strong aria-hidden="true">9.</strong> Deno Deploy</a></li><li class="chapter-item expanded "><a href="val-town.html"><strong aria-hidden="true">10.</strong> Val Town</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="cli.html">CLI Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smallweb</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/pomdtr/smallweb" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="why-smallweb"><a class="header" href="#why-smallweb">Why Smallweb?</a></h2>
<p>Smallweb maps each folder in <code>~/www</code> folder to an unique domain. Ex: <code>~/www/example</code> will be mapped to:</p>
<ul>
<li><code>https://example.localhost</code> on your local device</li>
<li><code>https://example.&lt;your-domain&gt;</code> on your homelab / VPS</li>
</ul>
<p>Creating a new website becomes as simple a creating a folder and opening the corresponding url in your browser. No need to configure a build step, or start a development server. And since servers are mapped to folders, you can manage them using standard unix tools like <code>cp</code>, <code>mv</code> or <code>rm</code>.</p>
<p>Every http request is sandboxed in a single deno subprocess by the smallweb evaluation server. If there is no activity on your website, no resources will be used on your server, making it a great solution for low-traffic websites.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>If you want your apps to be available on the internet, you'll need to buy a domain name, and point it to your server.
You can find more information on to do this in the <a href="./cloudflare/tunnel.html">Cloudflare Tunnel setup guide</a>.</p>
<p>If you prefer your to keep your apps local to your device, you can learn how to host your apps as <code>https://&lt;app&gt;.localhost</code> address in <a href="./localhost/localhost.html">this guide</a>. This option does not requires a domain name (or a server), but your app will only be available on your local device.</p>
<p>This guide will assumes that you have followed the <a href="./localhost/localhost.html">localhost setup guide</a>. If you haven't, just replace <code>https://&lt;app&gt;.localhost</code> with <code>https://&lt;app&gt;.&lt;your-domain&gt;</code> in the examples below.</p>
<h3 id="hosting-a-web-app"><a class="header" href="#hosting-a-web-app">Hosting a web app</a></h3>
<p>Every folder in the <code>~/www</code> directory is served statically by default. If the folder contains an <code>index.html</code> file, it will be served as the default page. Otherwise, the folder content will be listed.</p>
<p>To create a new website, just create a folder in the <code>~/www</code> directory, and add an <code>index.html</code> file in it.</p>
<pre><code class="language-html">&lt;!-- File: ~/www/example-website/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Smallweb - Host websites from your internet folder&lt;/title&gt;
  &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body class="bg-white flex items-center justify-center min-h-screen text-black"&gt;
  &lt;div class="border-4 border-black p-10 text-center"&gt;
    &lt;h1 class="text-6xl font-extrabold mb-4"&gt;Smallweb&lt;/h1&gt;
    &lt;p class="text-2xl mb-6"&gt;Host websites from your internet folder&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>To access the website, open <code>https://example-website.localhost</code> in your browser.</p>
<p>If you want to serve dynamic content instead, you'll need to create a file called <code>main.[js,ts,jsx,tsx]</code> at the root of the folder. The file should export a default object with a <code>fetch</code> method that takes a <code>Request</code> object as argument, and returns a <code>Response</code> object.</p>
<pre><code class="language-ts">// File: ~/www/example-server/main.ts

export default {
  fetch(request: Request) {
    const url = new URL(request.url);
    const name = url.searchParams.get("name") || "world";

    return new Response(`Hello, ${name}!`, {
      headers: {
        "Content-Type": "text/plain",
      },
    });
  },
}
</code></pre>
<p>To access the server, open <code>https://example-server.localhost</code> in your browser.</p>
<p>Smallweb use the <a href="https://deno.com">deno</a> runtime to evaluate the server code. You get typescript and jsx support out of the box, and you can import any module from the npm and jsr registry by prefixing the module name with <code>npm:</code> or <code>jsr:</code>.</p>
<p>As an example, the following code snippet use the <code>@hono/hono</code> extract params from the request url, and render jsx:</p>
<pre><code class="language-jsx">// File: ~/www/hono-example/main.tsx
/** @jsxImportSource jsr:@hono/hono/jsx **/

import { Hono } from "@hono/hono";

const app = new Hono();

app.get("/", c =&gt; c.html(&lt;h1&gt;Hello, world!&lt;/h1&gt;));

app.get("/:name", c =&gt; c.html(&lt;h1&gt;Hello, {c.req.param("name")}!&lt;/h1&gt;));

export default app;
</code></pre>
<p>No need to start a development server, or to compile the code. Smallweb will take care of everything for you.</p>
<p>You can just copy paste this code at <code>~/www/hono-example/main.tsx</code>, and open <code>https://hono-example.localhost</code> in your browser. The first load might take a few seconds, since deno is downloading the required modules, but subsequent loads will be instantaneous.</p>
<h3 id="setting-env-variables"><a class="header" href="#setting-env-variables">Setting env variables</a></h3>
<p>You can set environment variables for your app by creating a file called <code>.env</code> in the application folder.</p>
<p>Here is an example of a <code>.env</code> file:</p>
<pre><code class="language-env">BEARER_TOKEN=SECURE_TOKEN
</code></pre>
<p>Use the <code>Deno.env.get</code> method to access the environment variables in your app:</p>
<pre><code class="language-ts">// File: ~/www/demo/main.ts
export default function (req: Request) {
  if (req.headers.get("Authorization") !== `Bearer ${Deno.env.get("BEARER_TOKEN")}`) {
    return new Response("Unauthorized", { status: 401 });
  }

  return new Response(`I'm private!`, {
    headers: {
      "Content-Type": "text/plain",
    },
  });
}
</code></pre>
<p>If you want to set an environment variable for all your apps, you can create a <code>.env</code> file in the <code>~/www</code> directory.</p>
<h3 id="configuring-permissions"><a class="header" href="#configuring-permissions">Configuring permissions</a></h3>
<p>By default, a smallweb app can:</p>
<ul>
<li>read and write the current directory</li>
<li>access environment variables using <code>Deno.env.get</code></li>
<li>access the network with <code>fetch</code></li>
</ul>
<p>If you want to add more permissions to your app (or restrict it even further), you can either:</p>
<ul>
<li>add <code>smallweb.json</code> configuration file at the root of the folder</li>
<li>add a <code>smallweb</code> field in your <code>deno.json</code></li>
</ul>
<p>A json schema for the permissions file is available <a href="https://static.pomdtr.me/smallweb.schema.json">here</a>. See the deno docs to learn the <a href="https://docs.deno.com/runtime/manual/basics/permissions">available permissions</a>.</p>
<p>Here is the default config when no <code>smallweb.json</code> file is present:</p>
<pre><code class="language-json">{
  "$schema": "https://static.pomdtr.me/smallweb.schema.json",
  "permissions": {
    "env": true,
    "net": true,
    "read": ["."],
    "write": {
      "allow": ["."],
      "deny": [ "smallweb.json", "smallweb.jsonc", "deno.json", "deno.jsonc"]
    }
  }
}
</code></pre>
<p>If you want to add permissions to run a binary, you should start from it, then add the required permissions:</p>
<pre><code class="language-jsonc">{
  "$schema": "https://static.pomdtr.me/smallweb.schema.json",
  "permissions": {
    "run": ["/opt/homebrew/bin/gh"], // add the ability to run the gh binary
    "env": true,
    "net": true,
    "read": ["."],
    "write": {
      "allow": ["."],
      "deny": [ "smallweb.json", "smallweb.jsonc", "deno.json", "deno.jsonc"]
    }
  }
}
</code></pre>
<p>As a general rule, you should only add permissions that are required for your app to run. The more permissions you add, the more attack surface you expose to potential attackers. If you know what you are doing (or just don't care), you can allow all permissions by setting the <code>all</code> field to <code>true</code>.</p>
<pre><code class="language-jsonc">{
  "$schema": "https://static.pomdtr.me/smallweb.schema.json",
  "permissions": {
    "all": true // yolo!
  }
}
</code></pre>
<h3 id="registering-a-cli-command"><a class="header" href="#registering-a-cli-command">Registering a CLI command</a></h3>
<p>To add a cli command to your app, just create a file called <code>cli.[js,ts,jsx,tsx]</code> in the folder.</p>
<p>Here is an example of a simple cli command:</p>
<pre><code class="language-ts">// File: ~/www/demo/cli.ts
import { parseArgs } from "jsr:@std/cli/parse-args";

const flags = parseArgs(Deno.args, {
  string: ["name"],
});

console.log(`Hello, ${flags.name || "world"}!`);
</code></pre>
<p>To run the command, you can use the <code>smallweb run</code> command:</p>
<pre><code class="language-sh">$ smallweb run demo --name smallweb
Hello, smallweb!
</code></pre>
<p>Of course, you can define both an <code>main.ts</code> and a <code>cli.ts</code> file in the same folder.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This page will guide you through the process of setting up your local environment for smallweb on MacOS.</p>
<p>At the end of this process, each folder in <code>~/www</code> will be mapped to domain with a <code>.localhost</code> suffix. For example, the folder <code>~/www/example</code> will be accessible at <code>https://example.localhost</code>.</p>
<p>This setup is useful for developing and testing smallweb apps locally, without having to deploy them to the internet.</p>
<p>If you want to expose your apps to the internet instead, you can follow the <a href="localhost/../cloudflare/tunnel.html">Cloudflare Tunnel setup guide</a>.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The following diagram illustrates the architecture of the local setup:</p>
<p><img src="localhost/./architecture.excalidraw.png" alt="Localhost architecture" /></p>
<p>The components needed are:</p>
<ul>
<li>a dns server to map <code>.localhost</code> domains to <code>127.0.0.1</code> ip address (dnsmasq)</li>
<li>a reverse proxy to automatically generate https certificates for each domain, and redirect traffic to the smallweb evaluation server (caddy)</li>
<li>a service to map each domain to the corresponding folder in ~/www, and spawn a deno subprocess for each request (smallweb)</li>
<li>a runtime to evaluate the application code (deno)</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>In the future, we might provide a script to automate this process, but for now, it's a manual process.</p>
<h3 id="install-brew-required-to-install-smallweb-deno-caddy-and-dnsmasq"><a class="header" href="#install-brew-required-to-install-smallweb-deno-caddy-and-dnsmasq">Install Brew (required to install smallweb, deno, caddy, and dnsmasq)</a></h3>
<p>We'll use brew to install the required tools. If you don't have brew installed, you can run the following command:</p>
<pre><code class="language-sh">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
</code></pre>
<h3 id="install-deno-required-to-run-smallweb-apps"><a class="header" href="#install-deno-required-to-run-smallweb-apps">Install Deno (required to run smallweb apps)</a></h3>
<pre><code class="language-sh"># using brew
brew install deno go
</code></pre>
<h3 id="install-smallweb-and-register-it-as-a-service"><a class="header" href="#install-smallweb-and-register-it-as-a-service">Install smallweb, and register it as a service</a></h3>
<pre><code class="language-sh">git clone https://github.com/pomdtr/smallweb
cd smallweb &amp;&amp; go install
echo "export PATH=$PATH:$(go env GOPATH)/bin" &gt;&gt; ~/.zshrc
smallweb service install
</code></pre>
<p>Download the lastest version of smallweb from the <a href="https://github.com/pomdtr/smallweb/releases/latest">github releases</a>, and extract the smallweb binary to your $PATH.</p>
<h3 id="install-caddy-redirect-localhost-to-localhost7777"><a class="header" href="#install-caddy-redirect-localhost-to-localhost7777">Install Caddy (redirect *.localhost to localhost:7777)</a></h3>
<pre><code class="language-sh"># Install caddy
brew install caddy

# Write caddy configuration
cat &lt;&lt;EOF &gt; /opt/homebrew/etc/Caddyfile
*.localhost {
  tls internal {
    on_demand
  }

  reverse_proxy localhost:7777
}
EOF

# Run caddy in the background
brew services start caddy

# Add caddy https certificates to your keychain
caddy trust

mkdir -p ~/www
# Indicate to deno to use the keychain for tls certificates
echo "DENO_TLS_CA_STORE=system" &gt;&gt; ~/www/.env
</code></pre>
<h3 id="install-dnsmasq-map-localhost-address-to-127001"><a class="header" href="#install-dnsmasq-map-localhost-address-to-127001">Install dnsmasq (map *.localhost address to 127.0.0.1)</a></h3>
<pre><code class="language-sh"># Install dsnmasq
brew install dnsmasq

# Write dnsmasq configuration
echo "address=/.localhost/127.0.0.1" &gt;&gt; /opt/homebrew/etc/dnsmasq.conf

# Run dnsmasq in the background
sudo brew services start dnsmasq

# Indicates to the system to use dnsmasq for .localhost domains
sudo mkdir -p /etc/resolver
cat &lt;&lt;EOF | sudo tee -a /etc/resolver/localhost
nameserver 127.0.0.1
EOF
</code></pre>
<h2 id="testing-the-local-setup"><a class="header" href="#testing-the-local-setup">Testing the local setup</a></h2>
<p>First, let's create a dummy smallweb website:</p>
<pre><code class="language-sh">mkdir -p ~/www/example
CAT &lt;&lt;EOF &gt; ~/www/example/main.ts
export default {
  fetch() {
    return new Response("Smallweb is running", {
      headers: {
        "Content-Type": "text/plain",
      },
    });
  }
}
EOF
</code></pre>
<p>If everything went well, you should be able to access <code>https://example.localhost</code> in your browser, and see the message <code>Smallweb is running</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Cloudflare Tunnel is a <strong>free</strong> service that allows you to expose your local server to the internet, without having to expose your local IP address.</p>
<p>Additionally, it provides some protection against DDoS attacks, and allows you to use Cloudflare's other services like Access.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<ol>
<li>
<p>Make sure that you have a domain name that you can manage with Cloudflare.</p>
</li>
<li>
<p>Install smallweb on your server, and register it as a service.</p>
<pre><code class="language-ts">git clone https://github.com/pomdtr/smallweb
cd smallweb &amp;&amp; go install
smallweb service install
</code></pre>
</li>
<li>
<p>From your cloudflare dashboard, navigate to <code>Zero Trust &gt; Networks &gt; Tunnels</code></p>
</li>
<li>
<p>Click on <code>Create a tunnel</code>, and select the <code>Clouflared</code> option</p>
</li>
<li>
<p>Follow the intructions to install cloudflared, and create a connector on your device.</p>
</li>
<li>
<p>Add a wildcard hostname for your tunnel (ex: <code>*.&lt;your-domain&gt;</code>), and use <code>http://localhost:7777</code> as the origin service.</p>
<p><img src="cloudflare/./tunnel.png" alt="Tunnel Configuration" /></p>
</li>
<li>
<p>Copy the tunnel ID, and go to <code>Websites &gt; DNS &gt; Records</code>.</p>
</li>
<li>
<p>Add a new <code>CNAME</code> record for your wildcard hostname, with a target of <code>&lt;tunnel-id&gt;.cfargotunnel.com</code>.</p>
<p><img src="cloudflare/./dns.png" alt="DNS Configuration" /></p>
</li>
</ol>
<h2 id="checking-that-your-tunnel-is-running"><a class="header" href="#checking-that-your-tunnel-is-running">Checking that your tunnel is running</a></h2>
<p>Create a dummy smallweb app in <code>~/www</code></p>
<pre><code class="language-sh">mkdir -p ~/www/example
CAT &lt;&lt;EOF &gt; ~/www/example/main.ts
export default {
  fetch() {
    return new Response("Smallweb is running", {
      headers: {
        "Content-Type": "text/plain",
      },
    });
  }
}
EOF
</code></pre>
<p>If everything went well, you should be able to access <code>https://example.localhost</code> in your browser, and see the message <code>Smallweb is running</code>.</p>
<h2 id="optional-steps"><a class="header" href="#optional-steps">Optional Steps</a></h2>
<ul>
<li>You can protect your tunnel (or specific apps) with Cloudflare Access.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hosting-smallweb-on-flyio"><a class="header" href="#hosting-smallweb-on-flyio">Hosting Smallweb on fly.io</a></h1>
<pre><code class="language-sh">git clone https://github.com/pomdtr/smallweb
fly launch --no-deploy
fly deploy
fly certs create '&lt;your-domain&gt;' # Optional, might be used in the future
fly certs create '*.&lt;your-domain&gt;'
</code></pre>
<p>Then add the required dns entries to your domain registrar.</p>
<p><img src="fly/./dns.png" alt="DNS Entries" /></p>
<p>The certificate might take a long time to be issued (~30 mins in my experience).
You can check the status of the certificates by running <code>fly certs show '*.&lt;your-domain&gt;'</code>.</p>
<h2 id="testing-the-setup"><a class="header" href="#testing-the-setup">Testing the setup</a></h2>
<p>Create a dummy website:</p>
<pre><code class="language-sh">fly ssh console
mkdir -p /www/example
CAT &lt;&lt;EOF &gt; /www/example/main.ts
export default {
  fetch() {
    return new Response("Smallweb is running on fly.io", {
      headers: {
        "Content-Type": "text/plain",
      },
    });
  }
}
EOF
</code></pre>
<p>Then go to <code>https://example.&lt;your-domain&gt;</code>.</p>
<p>You can access the smallweb logs by running: <code>fly logs</code> in the smallweb directory, or <code>fly logs -a smallweb</code> from anywhere.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-services-with-hono"><a class="header" href="#creating-services-with-hono">Creating Services with Hono</a></h1>
<p>Hono is a fantastic library to create APIs in smallweb. It's a great match for smallweb, and the framework I recommend for creating APIs.</p>
<p>Below are some examples to get you started, adapted from the official <a href="https://hono.dev/docs/">Hono documentation</a></p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>Create a new <code>~/www/hono-example/main.ts</code> file with the following content:</p>
<pre><code class="language-ts">import { Hono } from 'jsr:@hono/hono'

const app = new Hono()

app.get('/', (c) =&gt; c.text('Hello Deno!'))

export default app;
</code></pre>
<p>Then navigate to <code>https://hono-example.localhost</code> to see the result.</p>
<h2 id="routing-requests"><a class="header" href="#routing-requests">Routing Requests</a></h2>
<pre><code class="language-ts">import { Hono } from 'jsr:@hono/hono'

const app = new Hono()

// HTTP Methods
app.get('/', (c) =&gt; c.text('GET /'))
app.post('/', (c) =&gt; c.text('POST /'))
app.put('/', (c) =&gt; c.text('PUT /'))
app.delete('/', (c) =&gt; c.text('DELETE /'))

// Wildcard
app.get('/wild/*/card', (c) =&gt; {
  return c.text('GET /wild/*/card')
})

// Any HTTP methods
app.all('/hello', (c) =&gt; c.text('Any Method /hello'))

// Custom HTTP method
app.on('PURGE', '/cache', (c) =&gt; c.text('PURGE Method /cache'))

// Multiple Method
app.on(['PUT', 'DELETE'], '/post', (c) =&gt;
  c.text('PUT or DELETE /post')
)

// Multiple Paths
app.on('GET', ['/hello', '/ja/hello', '/en/hello'], (c) =&gt;
  c.text('Hello')
)

export default app;
</code></pre>
<p>More information can be found in the <a href="https://hono.dev/docs/api/routing">Hono documentation</a>.</p>
<h2 id="middlewares"><a class="header" href="#middlewares">Middlewares</a></h2>
<p>Hono comes with a mature middleware system:</p>
<pre><code class="language-ts">import { Hono } from "jsr:@hono/hono";
import { logger } from "jsr:@hono/hono/logger";
import { bearerToken } from "jsr:@hono/hono/bearer-token";

// match any method, all routes
app.use(logger())

// specify path
app.use('/posts/*', bearerToken({
    verify(token) {
        return token === Deno.env.get('BEARER_TOKEN')
    }
}))


app.post('/posts', (c) =&gt; {
  return c.json({ message: 'Post created' })
})

export default app;
</code></pre>
<p>More information can be found in the <a href="https://hono.dev/docs/guides/middleware">Hono documentation</a>.</p>
<h2 id="serving-static-files"><a class="header" href="#serving-static-files">Serving static files</a></h2>
<p>To serve static files, use <code>serveStatic</code> imported from <code>hono/deno</code>.</p>
<pre><code class="language-ts">import { Hono } from 'hono'
import { serveStatic } from 'hono/deno'

const app = new Hono()

app.use('/static/*', serveStatic({ root: './' }))
app.use('/favicon.ico', serveStatic({ path: './favicon.ico' }))
app.get('/', (c) =&gt; c.text('You can access: /static/hello.txt'))
app.get('*', serveStatic({ path: './static/fallback.txt' }))

export default app;
</code></pre>
<p>For the above code, it will work well with the following directory structure.</p>
<pre><code class="language-txt">./www/hono-example
├── favicon.ico
├── main.ts
└── static
    ├── demo
    │   └── index.html
    ├── fallback.txt
    ├── hello.txt
    └── images
        └── dinotocat.png
</code></pre>
<h2 id="jsx-support"><a class="header" href="#jsx-support">JSX Support</a></h2>
<p>If you want to return html from your endpoint, hono comes with built-in support for JSX.</p>
<pre><code class="language-jsx">// @jsxImportSource jsr:@hono/hono/jsx

import { Hono } from 'jsr:@hono/hono'

const app = new Hono()

app.get('/', (c) =&gt; {
    return c.html(
        &lt;html&gt;
            &lt;head&gt;
                &lt;title&gt;Hello Deno!&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;Hello Deno!&lt;/h1&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    )
})

export default app;
</code></pre>
<p>More information can be found in the <a href="https://hono.dev/docs/guides/jsx">Hono documentation</a></p>
<h2 id="more"><a class="header" href="#more">More</a></h2>
<p>This is just a glimpse of what Hono can do. There are many other features available:</p>
<ul>
<li><a href="https://hono.dev/docs/guides/rpc">RPC</a></li>
<li><a href="https://hono.dev/docs/guides/validation">Request Validation</a></li>
<li><a href="https://hono.dev/docs/guides/error-handling">Error Handling</a></li>
<li>and more!</li>
</ul>
<p>Make sure to visit the <a href="https://hono.dev/docs">Hono documentation</a> for more information.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>If you're not a fan of Hono, you can also use one the following libraries:</p>
<ul>
<li><a href="https://deno.land/x/oak">Oak</a> used to be the most popular library for creating APIs in Deno</li>
<li><a href="https://deno.land/x/itty_router">itty-router</a> An ultra-tiny API microrouter</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-apps-from-jsr"><a class="header" href="#installing-apps-from-jsr">Installing Apps from JSR</a></h1>
<p>In Smallweb, we use <a href="https://jsr.io">JSR</a> to distribute webapps.
Think of it as a lightweight alternatives to docker images.</p>
<p>Apps can includes both the frontend and the backend, and can be installed with a single import statement.
To upgrade an app, you just change the version in the import statement.
To uninstall an app, you can just delete the folder.</p>
<p>Deno will take care of downloading the required modules, and caching them for future use.
It also gives us a secure way to run untrusted code, since we can restrict the permissions of the app.</p>
<p>By default, apps can:</p>
<ul>
<li>read and write files from their own directory</li>
<li>access environment variables using <code>Deno.env.get</code></li>
<li>access the network with <code>fetch</code></li>
</ul>
<p>But you can add more permissions to your app (or restrict it even further) by adding a <code>smallweb.json</code> file to the app directory.</p>
<h2 id="sqlite-explorer"><a class="header" href="#sqlite-explorer">SQLite Explorer</a></h2>
<p>Create a new file at <code>~/www/sqlite-explorer/main.ts</code> with the following content:</p>
<pre><code class="language-ts">import { serveDatabase } from "jsr:@pomdtr/sqlite-explorer@0.4.0/server";

const handler = serveDatabase({ dbPath: "./chinook.db" });

export default { fetch: handler };
</code></pre>
<p>Then download a sample database using:</p>
<pre><code class="language-txt">curl https://www.sqlitetutorial.net/wp-content/uploads/2018/03/chinook.zip -o /tmp/chinook.zip
unzip /tmp/chinook.zip -d ~/www/sqlite-explorer
</code></pre>
<p>This application needs some specific permissions to run, so we'll need to configure them in <code>~/www/sqlite-explorer/smallweb.json</code>.</p>
<pre><code class="language-json">{
    "permissions": {
        "read": ["."],
        "write": ["."],
        "ffi": true,
        "sys": true
    }
}
</code></pre>
<p>Here is what the ~/www/sqlite-explorer folder should look like:</p>
<pre><code class="language-txt">~/www/sqlite-explorer
├── chinook.db
├── main.ts
└── smallweb.json
</code></pre>
<p>You can now access your app at <code>https://sqlite-explorer.localhost</code> (or <code>https://sqlite-explorer.&lt;your-domain&gt;</code>).</p>
<p>If you don't want your database to be public, feel free to wrap it in a auth middleware:</p>
<pre><code class="language-ts">import { serveDatabase } from "jsr:@pomdtr/sqlite-explorer@0.4.0/server";
import { lastlogin } from "jsr:@pomdtr/lastlogin";

const handler = serveDatabase({ dbPath: "./chinook.db" });
const auth = lastlogin({
  verifyEmail: (email) =&gt; email === Deno.env.get("EMAIL"),
});

export default { fetch: auth(handler) };
</code></pre>
<p>And then set the required environment variable in your <code>.env</code> file:</p>
<pre><code class="language-txt">EMAIL=pomdtr@example.com
</code></pre>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Create a new file at <code>~/www/vscode/main.ts</code> with the following content:</p>
<pre><code class="language-ts">import { VSCode } from "jsr:@smallweb/vscode@0.0.2";
import { LocalFS } from "jsr:@smallweb/vscode@0.0.2/local-fs";
import { lastlogin } from "jsr:@pomdtr/lastlogin";

const fs = new LocalFS("..");
const vscode = new VSCode({ fs });
const auth = lastlogin({
  verifyEmail: (email) =&gt; email === Deno.env.get("EMAIL"),
});

export default {
  fetch: auth(vscode.fetch),
};
</code></pre>
<p>Here every parts is swappable: you can use a different fs, or a different auth middleware.</p>
<p>For example, the library also provides fs to manage your val.town blobs:</p>
<pre><code class="language-ts">import { VSCode } from "jsr:@smallweb/vscode@0.0.2";
import { ValTownFS } from "jsr:@smallweb/vscode@0.0.2/val-town";
import { lastlogin } from "jsr:@pomdtr/lastlogin";

const fs = new ValTownFS(Deno.env.get("VALTOWN_TOKEN")!);
const vscode = new VSCode({ fs });
const auth = lastlogin({
  verifyEmail: (email) =&gt; email === Deno.env.get("EMAIL"),
});

export default {
  fetch: auth(vscode.fetch),
};
</code></pre>
<p>To use it, you'll need to set the required environment variables in your <code>.env</code> file:</p>
<pre><code class="language-txt">VALTOWN_TOKEN=&lt;your-token&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-vite"><a class="header" href="#integrating-with-vite">Integrating with Vite</a></h1>
<p>Smallweb can easily integrate with <a href="https://vitejs.dev">vite</a> to provide a fast development experience.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Our project will have the following structure:</p>
<pre><code class="language-txt">~/www/vite-example
├── .vscode/
│   └── settings.json
├── main.ts
└── frontend/
    └── &lt;vite project&gt;
</code></pre>
<p>Let's create the project, and initialize the vite frontend:</p>
<pre><code class="language-sh">mkdir -p ~/www/vite-example
cd ~/www/vite-example
npm create vite@latest frontend
cd frontend &amp;&amp; npm install &amp;&amp; npm run build
</code></pre>
<p>Then we'll create the main.ts file:</p>
<pre><code class="language-ts">import { serveDir } from "jsr:@std/http/file-server";

const handler = (req: Request) =&gt; {
    return serveDir(req, {
        fsRoot: "./frontend/dist",
    });
};

export default {
    fetch: handler,
};
</code></pre>
<p>And setup the <code>.vscode/settings.json</code> config:</p>
<pre><code class="language-json">{
    "deno.enable": true,
    "deno.disablePaths": [
        "frontend"
    ],
}
</code></pre>
<p>Once everything is setup, you should be able to access the website at <code>https://vite-example.localhost</code>.</p>
<h2 id="adding-api-endpoints"><a class="header" href="#adding-api-endpoints">Adding api endpoints</a></h2>
<p>You can modify the <code>main.ts</code> file to add api endpoints. <a href="https://hono.dev">Hono</a> pairs well with vite for this.</p>
<p>If you need a store small amounts of data, <a href="https://kv.deno.dev">Deno KV</a> is a good option.</p>
<pre><code class="language-ts">import { Hono } from "jsr:@hono/hono";

const app = new Hono();

const kv = await Deno.openKv()

// register api endpoints
app.get("/posts", async (c) =&gt; {
    const posts = await kv.list(["posts"])
    );

    return c.json(posts.value);
});

app.get("/posts/:id", async (c) =&gt; {
    const post = await kv.get(["posts", c.req.param("id")]);
    return c.json(post.value);
});

app.post("/posts", async (c) =&gt; {
    const post = await c.req.json();
    await kv.set(["posts", post.id], post);

    return c.json(post, { status: 201 });
});

// serve the frontend
app.get('*', serveStatic({ root: './frontend/dist' }))

export default app;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-astro"><a class="header" href="#integrating-with-astro">Integrating with Astro</a></h1>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<p>Our project will have the following structure:</p>
<pre><code class="language-txt">~/www/astro-example
├── .vscode/
│   └── settings.json
├── main.ts
└── app/
    └── &lt;astro project&gt;
</code></pre>
<p>Let's create the project, and initialize the astro frontend:</p>
<pre><code class="language-sh">mkdir -p ~/www/astro-example
cd ~/www/astro-example
npm create astro@latest app
</code></pre>
<p>In order to enable ssr, we'll need run <code>npm install @deno/astro-adapter</code>, then update the astro.config.mjs file:</p>
<pre><code class="language-ts">import { defineConfig } from 'astro/config';
import deno from "@deno/astro-adapter";


// https://astro.build/config
export default defineConfig({
    output: "server",
    adapter: deno({
        start: false,
    })
});
</code></pre>
<p>We'll also create the main.ts file:</p>
<pre><code class="language-ts">import { handle } from "./app/dist/server/entry.mjs";
import { serveDir } from "jsr:@std/http/file-server";

export default {
    async fetch(req: Request) {
        // try to serve static files from the client directory
        const res = await serveDir(req, {
            fsRoot: "./app/dist/client",
        });
        if (res.status !== 404) {
            return res;
        }

        // if the file was not found, pass the request to the app
        return handle(req);
    },
};
</code></pre>
<p>And setup the <code>.vscode/settings.json</code> config:</p>
<pre><code class="language-json">{
    "deno.enable": true,
    "deno.disablePaths": [
        "frontend"
    ],
}
</code></pre>
<p>Now that everything is setup, we can just run <code>npm run build</code> in the <code>~/www/astro-example/app</code> directory, and access the website at <code>https://astro-example.localhost</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-telegram-bot"><a class="header" href="#building-a-telegram-bot">Building a Telegram Bot</a></h1>
<p>In this guide, we'll build a simple Telegram bot that will echo back any message that is sent to it.</p>
<p>The telegram API is documented <a href="https://core.telegram.org/bots/api">here</a>.</p>
<h2 id="create-a-new-bot"><a class="header" href="#create-a-new-bot">Create a new bot</a></h2>
<p>To create a new bot, you will need to talk to the <a href="https://t.me/botfather">BotFather</a> on Telegram.</p>
<ol>
<li>Open Telegram and search for <code>@botfather</code>.</li>
<li>Send <code>/newbot</code> command to the BotFather.</li>
<li>Follow the instructions to create a new bot.</li>
<li>Once you have created the bot, the BotFather will give you a token. Save this token as you will need it later</li>
</ol>
<h2 id="create-the-webhook-handler"><a class="header" href="#create-the-webhook-handler">Create the webhook handler</a></h2>
<p>Create a new file at <code>~/www/telegram-echo-bot/main.ts</code> with the following content:</p>
<pre><code class="language-ts">const token = Deno.env.get("BOT_TOKEN");
if (!token) {
    throw new Error("BOT_TOKEN is required");
}

const apiURL = `https://api.telegram.org/bot${token}`;

type Update = {
    update_id: number;
    message?: {
        text?: string;
        chat: {
            id: number;
        };
    };
};

const handler = async (req: Request) =&gt; {
    if (req.method === "GET") {
        return new Response("Telegram bot is up and running");
    }

    const update: Update = await req.json();
    await fetch(`${apiURL}/sendMessage`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            chat_id: update.message?.chat.id,
            text: update.message?.text,
        }),
    });
    return new Response("OK");
};

export default {
    fetch: handler,
};
</code></pre>
<p>Then create a .env file at <code>~/www/telegram-echo-bot/.env</code> with the following content:</p>
<pre><code class="language-txt">BOT_TOKEN=&lt;your-token&gt;
</code></pre>
<h2 id="setup-the-webhook"><a class="header" href="#setup-the-webhook">Setup the webhook</a></h2>
<pre><code class="language-sh">export BOT_TOKEN=&lt;your-bot-token&gt;
export WEBHOOK_URL=https://telegram-echo-bot.&lt;your-domain&gt;
curl -X POST https://api.telegram.org/bot$BOT_TOKEN/setWebhook -d "url=$WEBHOOK_URL"
</code></pre>
<h2 id="recommendations"><a class="header" href="#recommendations">Recommendations</a></h2>
<p><a href="https://grammy.dev/">grammY</a> is my recommended library for building complex Telegram bots in Deno.</p>
<pre><code class="language-ts">import { Bot, webhookCallback } from "https://deno.land/x/grammy@v1.26.0/mod.ts";

// Create an instance of the `Bot` class and pass your bot token to it.
const bot = new Bot(""); // &lt;-- put your bot token between the ""

// You can now register listeners on your bot object `bot`.
// grammY will call the listeners when users send messages to your bot.

// Handle the /start command.
bot.command("start", (ctx) =&gt; ctx.reply("Welcome! Up and running."));
// Handle other messages.
bot.on("message", (ctx) =&gt; ctx.reply("Got another message!"));

export default {
    fetch: webhookCallback(bot)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deno-deploy"><a class="header" href="#deno-deploy">Deno Deploy</a></h1>
<p>If one of your websites is starting to get a lot of traffic, you might want to deploy it to a cloud provider.</p>
<p>Deno Deploy is a cloud platform that allows you to deploy your Deno apps with ease. It's a great choice for smallweb apps, since it's built on top of Deno, and it's very easy to use.</p>
<p>To deploy an app, you'll just need to:</p>
<ol>
<li>
<p>Install the <code>deployctl</code> cli:</p>
<pre><code class="language-sh">deno install -Arf jsr:@deno/deployctl
</code></pre>
</li>
<li>
<p>Run <code>deployctl deploy</code>, and follow the instructions.</p>
</li>
</ol>
<p>Beware, all Deno APIs are not available in Deno Deploy. For example, you won't be able to write files to the filesystem.</p>
<h1 id=""><a class="header" href="#"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="val-town"><a class="header" href="#val-town">Val Town</a></h1>
<p>Val Town is a social website to write and deploy TypeScript.</p>
<p>Val Town and Smallweb can easily interop. For example, to use an http val in smallweb, you can use the following snippet:</p>
<pre><code class="language-ts">// Assuming that the val export a handler function
import handler from "https://esm.town/v/&lt;username&gt;/&lt;val&gt;"

export default {
  fetch: handler,
};
</code></pre>
<p>You can also go the other way around. A great way to achieve this is to push you smallweb app to a github repository, and use the raw url to import the app in Val Town.</p>
<pre><code class="language-ts">import handler from "https://raw.githubusercontent.com/&lt;username&gt;/&lt;repo&gt;/&lt;branch&gt;/mod.ts"

export default handler
</code></pre>
<p>You can also push reusable block to <a href="https://jsr.io">JSR</a>, and access them from both Val Town and Smallweb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<h2 id="smallweb"><a class="header" href="#smallweb">smallweb</a></h2>
<p>Host websites from your internet folder</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<pre><code>  -h, --help   help for smallweb
</code></pre>
<h2 id="smallweb-completion"><a class="header" href="#smallweb-completion">smallweb completion</a></h2>
<p>Generate the autocompletion script for the specified shell</p>
<h3 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h3>
<p>Generate the autocompletion script for smallweb for the specified shell.
See each sub-command's help for details on how to use the generated script.</p>
<h3 id="options-1"><a class="header" href="#options-1">Options</a></h3>
<pre><code>  -h, --help   help for completion
</code></pre>
<h2 id="smallweb-completion-bash"><a class="header" href="#smallweb-completion-bash">smallweb completion bash</a></h2>
<p>Generate the autocompletion script for bash</p>
<h3 id="synopsis-1"><a class="header" href="#synopsis-1">Synopsis</a></h3>
<p>Generate the autocompletion script for the bash shell.</p>
<p>This script depends on the 'bash-completion' package.
If it is not installed already, you can install it via your OS's package manager.</p>
<p>To load completions in your current shell session:</p>
<pre><code>source &lt;(smallweb completion bash)
</code></pre>
<p>To load completions for every new session, execute once:</p>
<h4 id="linux"><a class="header" href="#linux">Linux:</a></h4>
<pre><code>smallweb completion bash &gt; /etc/bash_completion.d/smallweb
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS:</a></h4>
<pre><code>smallweb completion bash &gt; $(brew --prefix)/etc/bash_completion.d/smallweb
</code></pre>
<p>You will need to start a new shell for this setup to take effect.</p>
<pre><code>smallweb completion bash
</code></pre>
<h3 id="options-2"><a class="header" href="#options-2">Options</a></h3>
<pre><code>  -h, --help              help for bash
      --no-descriptions   disable completion descriptions
</code></pre>
<h2 id="smallweb-completion-fish"><a class="header" href="#smallweb-completion-fish">smallweb completion fish</a></h2>
<p>Generate the autocompletion script for fish</p>
<h3 id="synopsis-2"><a class="header" href="#synopsis-2">Synopsis</a></h3>
<p>Generate the autocompletion script for the fish shell.</p>
<p>To load completions in your current shell session:</p>
<pre><code>smallweb completion fish | source
</code></pre>
<p>To load completions for every new session, execute once:</p>
<pre><code>smallweb completion fish &gt; ~/.config/fish/completions/smallweb.fish
</code></pre>
<p>You will need to start a new shell for this setup to take effect.</p>
<pre><code>smallweb completion fish [flags]
</code></pre>
<h3 id="options-3"><a class="header" href="#options-3">Options</a></h3>
<pre><code>  -h, --help              help for fish
      --no-descriptions   disable completion descriptions
</code></pre>
<h2 id="smallweb-completion-help"><a class="header" href="#smallweb-completion-help">smallweb completion help</a></h2>
<p>Help about any command</p>
<h3 id="synopsis-3"><a class="header" href="#synopsis-3">Synopsis</a></h3>
<p>Help provides help for any command in the application.
Simply type completion help [path to command] for full details.</p>
<pre><code>smallweb completion help [command] [flags]
</code></pre>
<h3 id="options-4"><a class="header" href="#options-4">Options</a></h3>
<pre><code>  -h, --help   help for help
</code></pre>
<h2 id="smallweb-completion-powershell"><a class="header" href="#smallweb-completion-powershell">smallweb completion powershell</a></h2>
<p>Generate the autocompletion script for powershell</p>
<h3 id="synopsis-4"><a class="header" href="#synopsis-4">Synopsis</a></h3>
<p>Generate the autocompletion script for powershell.</p>
<p>To load completions in your current shell session:</p>
<pre><code>smallweb completion powershell | Out-String | Invoke-Expression
</code></pre>
<p>To load completions for every new session, add the output of the above command
to your powershell profile.</p>
<pre><code>smallweb completion powershell [flags]
</code></pre>
<h3 id="options-5"><a class="header" href="#options-5">Options</a></h3>
<pre><code>  -h, --help              help for powershell
      --no-descriptions   disable completion descriptions
</code></pre>
<h2 id="smallweb-completion-zsh"><a class="header" href="#smallweb-completion-zsh">smallweb completion zsh</a></h2>
<p>Generate the autocompletion script for zsh</p>
<h3 id="synopsis-5"><a class="header" href="#synopsis-5">Synopsis</a></h3>
<p>Generate the autocompletion script for the zsh shell.</p>
<p>If shell completion is not already enabled in your environment you will need
to enable it.  You can execute the following once:</p>
<pre><code>echo "autoload -U compinit; compinit" &gt;&gt; ~/.zshrc
</code></pre>
<p>To load completions in your current shell session:</p>
<pre><code>source &lt;(smallweb completion zsh)
</code></pre>
<p>To load completions for every new session, execute once:</p>
<h4 id="linux-1"><a class="header" href="#linux-1">Linux:</a></h4>
<pre><code>smallweb completion zsh &gt; "${fpath[1]}/_smallweb"
</code></pre>
<h4 id="macos-1"><a class="header" href="#macos-1">macOS:</a></h4>
<pre><code>smallweb completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_smallweb
</code></pre>
<p>You will need to start a new shell for this setup to take effect.</p>
<pre><code>smallweb completion zsh [flags]
</code></pre>
<h3 id="options-6"><a class="header" href="#options-6">Options</a></h3>
<pre><code>  -h, --help              help for zsh
      --no-descriptions   disable completion descriptions
</code></pre>
<h2 id="smallweb-docs"><a class="header" href="#smallweb-docs">smallweb docs</a></h2>
<p>Generate smallweb cli documentation</p>
<pre><code>smallweb docs [flags]
</code></pre>
<h3 id="options-7"><a class="header" href="#options-7">Options</a></h3>
<pre><code>  -h, --help   help for docs
</code></pre>
<h2 id="smallweb-dump"><a class="header" href="#smallweb-dump">smallweb dump</a></h2>
<p>Print the smallweb app tree</p>
<pre><code>smallweb dump [flags]
</code></pre>
<h3 id="options-8"><a class="header" href="#options-8">Options</a></h3>
<pre><code>  -h, --help   help for dump
</code></pre>
<h2 id="smallweb-help"><a class="header" href="#smallweb-help">smallweb help</a></h2>
<p>Help about any command</p>
<h3 id="synopsis-6"><a class="header" href="#synopsis-6">Synopsis</a></h3>
<p>Help provides help for any command in the application.
Simply type smallweb help [path to command] for full details.</p>
<pre><code>smallweb help [command] [flags]
</code></pre>
<h3 id="options-9"><a class="header" href="#options-9">Options</a></h3>
<pre><code>  -h, --help   help for help
</code></pre>
<h2 id="smallweb-run"><a class="header" href="#smallweb-run">smallweb run</a></h2>
<p>Run a smallweb app cli</p>
<pre><code>smallweb run &lt;alias&gt; [args...] [flags]
</code></pre>
<h3 id="options-10"><a class="header" href="#options-10">Options</a></h3>
<pre><code>  -h, --help   help for run
</code></pre>
<h2 id="smallweb-service"><a class="header" href="#smallweb-service">smallweb service</a></h2>
<p>Manage smallweb service</p>
<h3 id="options-11"><a class="header" href="#options-11">Options</a></h3>
<pre><code>  -h, --help   help for service
</code></pre>
<h2 id="smallweb-service-help"><a class="header" href="#smallweb-service-help">smallweb service help</a></h2>
<p>Help about any command</p>
<h3 id="synopsis-7"><a class="header" href="#synopsis-7">Synopsis</a></h3>
<p>Help provides help for any command in the application.
Simply type service help [path to command] for full details.</p>
<pre><code>smallweb service help [command] [flags]
</code></pre>
<h3 id="options-12"><a class="header" href="#options-12">Options</a></h3>
<pre><code>  -h, --help   help for help
</code></pre>
<h2 id="smallweb-service-install"><a class="header" href="#smallweb-service-install">smallweb service install</a></h2>
<p>Install smallweb as a service</p>
<pre><code>smallweb service install [flags]
</code></pre>
<h3 id="options-13"><a class="header" href="#options-13">Options</a></h3>
<pre><code>  -h, --help   help for install
</code></pre>
<h2 id="smallweb-service-log"><a class="header" href="#smallweb-service-log">smallweb service log</a></h2>
<p>Print service logs</p>
<pre><code>smallweb service log [flags]
</code></pre>
<h3 id="options-14"><a class="header" href="#options-14">Options</a></h3>
<pre><code>  -f, --follow   Follow log output
  -h, --help     help for log
</code></pre>
<h2 id="smallweb-service-restart"><a class="header" href="#smallweb-service-restart">smallweb service restart</a></h2>
<p>Restart smallweb service</p>
<pre><code>smallweb service restart [flags]
</code></pre>
<h3 id="options-15"><a class="header" href="#options-15">Options</a></h3>
<pre><code>  -h, --help   help for restart
</code></pre>
<h2 id="smallweb-service-start"><a class="header" href="#smallweb-service-start">smallweb service start</a></h2>
<p>Start smallweb service</p>
<pre><code>smallweb service start [flags]
</code></pre>
<h3 id="options-16"><a class="header" href="#options-16">Options</a></h3>
<pre><code>  -h, --help   help for start
</code></pre>
<h2 id="smallweb-service-status"><a class="header" href="#smallweb-service-status">smallweb service status</a></h2>
<p>View service status</p>
<pre><code>smallweb service status [flags]
</code></pre>
<h3 id="options-17"><a class="header" href="#options-17">Options</a></h3>
<pre><code>  -h, --help   help for status
</code></pre>
<h2 id="smallweb-service-stop"><a class="header" href="#smallweb-service-stop">smallweb service stop</a></h2>
<p>Stop smallweb service</p>
<pre><code>smallweb service stop [flags]
</code></pre>
<h3 id="options-18"><a class="header" href="#options-18">Options</a></h3>
<pre><code>  -h, --help   help for stop
</code></pre>
<h2 id="smallweb-service-uninstall"><a class="header" href="#smallweb-service-uninstall">smallweb service uninstall</a></h2>
<p>Uninstall smallweb service</p>
<pre><code>smallweb service uninstall [flags]
</code></pre>
<h3 id="options-19"><a class="header" href="#options-19">Options</a></h3>
<pre><code>  -h, --help   help for uninstall
</code></pre>
<h2 id="smallweb-up"><a class="header" href="#smallweb-up">smallweb up</a></h2>
<p>Start the smallweb evaluation server</p>
<pre><code>smallweb up [flags]
</code></pre>
<h3 id="options-20"><a class="header" href="#options-20">Options</a></h3>
<pre><code>  -h, --help       help for up
  -p, --port int   Port to listen on (default 7777)
</code></pre>
<!-- markdownlint-disable-file -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
